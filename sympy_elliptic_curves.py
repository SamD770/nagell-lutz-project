import sympy


def divisors(num: int) -> list[int]:
    pass


class RationalPoint:
    def has_integer_coords(self):
        pass

    def gradient_between(self, other) -> sympy.Q:
        pass


class RationalCurvePoint(RationalPoint):
    def __init__(self, x, y, parent_curve):
        self.x = x
        self.y = y
        self.parent_curve = parent_curve

    def __add__(self, other) -> "RationalCurvePoint":
        T = self.parent_curve.project_line(self, other)
        point_sum = self.parent_curve.project_line(T, self.parent_curve.zero_point)
        return point_sum


class CubicCurve:
    def __init__(self, coefficients, zero_point):
        self.zero_point = zero_point
        self.F = sympy.Poly()

    def discriminant(self) -> int:
        return 123

    def finite_order_points(self) -> list[RationalCurvePoint]:
        # Finds the finite ordered points on the elliptic curve and then maps them back onto our curve.
        elliptic = self.to_vnf()
        finite_order_points = []
        for elliptic_point in elliptic.finite_order_points():
            point = self.inverse_vnf_isomorphism(elliptic_point)
            finite_order_points.append(point)
        return finite_order_points

    def to_vnf(self) -> "EllipticCurve":
        pass

    def vnf_isomorphism(self, P: RationalCurvePoint) -> RationalCurvePoint:
        pass

    def inverse_vnf_isomorphism(self, P: RationalCurvePoint) -> RationalCurvePoint:
        pass

    def on_curve(self, P: RationalCurvePoint) -> bool:
        return self.F(P) == 0

    def project_line(self, P: RationalCurvePoint, Q: RationalCurvePoint) -> RationalCurvePoint:
        """Returns the third intersection point of the line going through P and Q."""
        grad = P.gradient_between(Q)


class EllipticCurve(CubicCurve):
    def f(self, x):
        pass

    def finite_ordered_points(self):

        finite_ordered_points = set(self.zero_point)

        def test_point(P):
            # Run through P, 2P, 3P ... 12P checking if they are finite ordered
            nP = P
            candidate_points = [P]
            # using Mazur's theorem; the order of P must be <= 12
            for n in range(1, 13):
                nP = nP + P
                candidate_points.append(nP)
                # If nP is zero, then we store all the points generated by it.
                if nP == self.zero_point:
                    for point in candidate_points:
                        finite_ordered_points.add(point)
                # If nP doesn't have integer coordinates, then we know it and P don't have finite order
                elif nP.has_integer_coords():
                    continue
                else:
                    break

        # Using the Nagell-Lutz theorem, x and y must be integers
        # that divide the constant term and discriminant respectively
        for y in divisors(self.discriminant()):
            constant_term = self.c - y ** 2
            for x in divisors(constant_term):
                if y ** 2 == self.f(x):
                    P = RationalCurvePoint(x, y, self)
                    test_point(P)

        return finite_ordered_points


